% Author: Riley Culberg
% Date: 12/7/2020
%
% This scripts uses the layer detection algorithm described Culberg &
% Schroeder, "Strong Potential for the Detection of Refrozen Ice Layers in
% Greenland's Firn," IGARSS 2020 to detect potential ice layers in CReSIS
% L1B Accumulation Radar radargrams. 
%
% Outputs:
% [Date]_Layer.mat file for each flight. This is a 1xP cell array with one
% cell for each radargrams (segments) in the flight transect. Each cell
% contains the following data structures:
%    data - MxN matrix of doubles, where M is the fast time axis and N is
%    the along-track axis. This takes a value of -200 if no ice layer is
%    detected at a given sample and the geometrically corrected radar
%    received power in dB if a layer is detected.
%    lat - N vector of latitude of each trace (WGS84)
%    lon - N vector of longitude for each trace (WGS84)
%    elev - N vector of surface elevation for each trace (WGS84)
%
% Data dependencies:
% CReSIS L1B radargrams for the transects being run. Due to the large data
% size, a single radargram is included as demo data for this function in
% /DemoData/Data_20170422_01_158.mat. 
% Retracked surface location - /DemoData/Demo_Surface.mat
% These retracked surface files can also be generated by running
% SurfaceTracker_KU.m on the radargrams of interest
%
% ------------------------------------------------------------------------

clear;

addpath(genpath('./ReferenceFunctions/'));

% Suppress MATLAB warnings for poor polynomial fits - this data gets thrown
% out anyway
warning('off', 'MATLAB:polyfit:RepeatedPointsOrRescale');

% List of flight transects to process by CReSIS date handle
flights = ["20170422_01"]; 
% List of radargrams within each transect to process by CReSIS numbering
% system
segments{1} = [158];  

starter = 100;  
base_dir = './DemoData/';
out_dir = './DerivedData/';
out_dir = './ExpectedOutput/';
surf_dir = './DemoData/';

% Detect ice layers for every radargram in every flight transect
for k = 1:length(flights)
    fprintf("Date: %s\n", flights(k));
    results = cell(1, length(segments{k}));
    surf = cell(1, length(segments{k}));
    
    % Load the retracked surface location
    surface_file = strcat(surf_dir, "Demo_Surface.mat");
    load(surface_file);
    
    for m = 1:length(segments{k})
        
        if m < length(segments{k})
            fprintf("%d...", segments{k}(m));
        else
            fprintf("%d\n", segments{k}(m));
        end
        
        % Data structure to hold results
        flight_results.data = [];
        flight_results.lat = [];
        flight_results.lon = [];
        flight_results.elev = [];
        
        % Load radargram
        if segments{k}(m) < 10
            file1 = strcat(base_dir, "/Data_", flights(k), "_00", num2str(segments{k}(m)), ".mat");
        elseif segments{k}(m) < 100
            file1 = strcat(base_dir, "/Data_", flights(k), "_0", num2str(segments{k}(m)), ".mat");
        else
            file1 = strcat(base_dir, "/Data_", flights(k), "_", num2str(segments{k}(m)), ".mat");
        end
        load(file1);
        
        % Populate the latitude and longitude outputs
        flight_results.lat = [flight_results.lat Latitude];
        flight_results.lon = [flight_results.lon Longitude];
        
        % Fast time sampling difference
        del_t = mean(diff(Time));
        
        % Load the surface
        if k == 11
            surface_ind = surf{m + 21};
        else
            surface_ind = surf{m};
        end
        
        % Calculate the surface elevation
        surf_elevation = Elevation - 0.5*del_t*surface_ind*3e8;
        flight_results.elev = [flight_results.elev surf_elevation];
        
        % Estimate the noise floor cutoff from the radargram 
        noise_u = size(Data,1) - 600;
        noise_b = noise_u + 100;
        noise_l = round(0.5*size(Data,2));
        noise_r =  noise_l + 100;
        
        noise_floor = mean(mean(10*log10(Data(noise_u:noise_b, noise_l:noise_r))));
        
        % Set cutoff relative to noise floor (this generally needs to be
        % tuned for each flight transect to make sure that the cutoff
        % happens above the first surface multiple
        noise_cutoff = noise_floor + 30;
        
        % For each trace, find the point where the average power falls
        % below the noise cutoff
        bottom_ind = zeros(size(surface_ind));
        for p = 1:size(Data,2)
            if ~isnan(surface_ind(p))
                index = surface_ind(p);
                val = 10*log10(mean(Data(index-10:index+10,p)));
                while val > noise_cutoff
                    index = index + 1;
                    val = mean(10*log10(Data(index-10:index+10,p)));
                end
                bottom_ind(p) = index;
            end
        end
        
        % Detect the ice layers
        ice_layers = -200*ones(50, size(Data, 2));  
        for p = 1:size(Data,2)
            
            if ~isnan(surface_ind(p)) && abs(Roll(p)) < 0.05 
                
                % Clip trace to region between surface and noise cutoff 
                start = surface_ind(p);
                stop = bottom_ind(p);
                
                depth = 0.5*(Time - Time(start))*(3e8/1.4);
                depth = depth(start:stop);
                
                data = 10*log10(Data(start:stop, p));
                
                % Find the upper and lower envelopes of the trace
                minima = [];
                maxima = [];    %[1]
                for q = 2:length(data)-1
                    if data(q-1) > data(q) && data(q+1) > data(q)
                        minima = [minima q];
                    end
                    if data(q-1) < data(q) && data(q+1) < data(q)
                        maxima = [maxima q];
                    end
                end
                
                double_minima  = [];   % [minima(1)]
                double_maxima = [];
                for q = 2:length(minima)-1
                    if data(minima(q-1)) > data(minima(q)) && data(minima(q+1)) > data(minima(q))
                        double_minima = [double_minima minima(q)];
                    end
                end
                
                for q = 2:length(maxima)-1
                    if data(maxima(q-1)) < data(maxima(q)) && data(maxima(q+1)) < data(maxima(q))
                        double_maxima = [double_maxima maxima(q)];
                    end
                end
                
                if ~isempty(double_minima)
                    
                    % Fit a fifth order polynomial to the upper and lower
                    % envelopes
                    p1 = polyfit(depth(double_minima), data(double_minima), 5);
                    lower = polyval(p1, depth);
                    p2 = polyfit(depth(double_maxima), data(double_maxima), 5);
                    upper = polyval(p2, depth);
                    
                    % Detrended the trace with mean of the upper and lower
                    % envelopes
                    detrended = data - (lower + 0.5*mean(abs(upper - lower)));
                    
                    % Assume that typicaly seasonal layering occurs in the
                    % bottom 2/3 of the trace and set the detection
                    % criteria is 3 times the standard deviation of the
                    % power in that region
                    cutoff = round(length(depth)/3);
                    threshold =  3*std(data(cutoff:end) - (lower(cutoff:end) + 0.5*mean(abs(upper - lower))));
                    
                    if length(detrended) <= 50
                        hold = length(detrended)-1;
                    else
                        hold = 50;
                    end
                    
                    % Find every peak that exceeds the threshold
                    for q = 2:hold
                        if detrended(q) >= threshold && data(q-1) < data(q) && data(q+1) < data(q)
                            % Geometrically correct the layer power of each
                            % detection and save to data structure
                            h = 0.5*3e8*Time(surface_ind(p));
                            d = 0.5*(Time(surface_ind(p) + q) - Time(surface_ind(p)))*(3e8/1.4);
                            geom = 20*log10(2*(h + d/1.4));
                            ice_layers(q,p) = data(q) + geom;
                        end
                    end
                else
                    % If upper and lower envelopes fail to be detected, set
                    % the whole trace results to NaN
                    ice_layers(:,p) = NaN;
                end
            else
               % If roll exceeds 0.05 rad or no surface detected, set
               % the whole trace to NaN since results aren't reliable
                ice_layers(:,p) = NaN;
            end
            
        end
        
        % Save results to full data structure
        flight_results.data = [flight_results.data ice_layers];
        results{m} = flight_results;
        surf{m} = surface_ind;
    end
    
    % Save full data structure to file
    out_file1 = strcat(out_dir, "Demo_Layer_Detections.mat");
    save(out_file1, 'results');
end



